package cmd

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/MRQ67/stackmatch-cli/internal/utils"
	"github.com/MRQ67/stackmatch-cli/pkg/installer"
	"github.com/MRQ67/stackmatch-cli/pkg/supabase"
	"github.com/MRQ67/stackmatch-cli/pkg/types"
	"github.com/spf13/cobra"
)

var (
	dryRun   bool
	sourceSupabase bool
	supabaseID   string
)

var importCmd = &cobra.Command{
	Use:   "import [filename]",
	Short: "Import a development environment from a file or Supabase",
	Long: `Reads a StackMatch environment from a file or downloads it from Supabase and installs the tools and configurations.

By default, this command runs in dry-run mode, showing what would be installed
without making any changes. Use the --no-dry-run flag to perform the actual installation.

When using --source=supabase, authentication is required.

You can specify either a local file or use --from-supabase with --id to import from Supabase.`,
	PreRunE: func(cmd *cobra.Command, args []string) error {
		// Only require auth if using Supabase source
		if sourceSupabase {
			return requireAuth(cmd, args)
		}
		return nil
	},
	Args: func(cmd *cobra.Command, args []string) error {
		if !sourceSupabase && len(args) != 1 {
			return fmt.Errorf("requires a filename argument when not using --from-supabase")
		}
		if sourceSupabase && supabaseID == "" {
			return fmt.Errorf("--id is required when using --from-supabase")
		}
		return nil
	},
	Run: func(cmd *cobra.Command, args []string) {
		var envData types.EnvironmentData
		var err error

		if sourceSupabase {
			// Validate config
			if err := cfg.Validate(); err != nil {
				log.Fatalf("Configuration error: %v", err)
			}

			// Download from Supabase
			supabaseClient, err := supabase.NewClient(cfg.SupabaseURL, cfg.SupabaseAPIKey)
			if err != nil {
				utils.ExitWithError(fmt.Errorf("failed to initialize Supabase client: %w", err))
			}

			env, err := supabaseClient.GetEnvironment(cmd.Context(), supabaseID)
			if err != nil {
				utils.ExitWithError(fmt.Errorf("failed to download environment from Supabase: %w", err))
			}
			envData = *env
		} else {
			// Read from local file
			inputFile := args[0]
			fileContent, err := os.ReadFile(inputFile)
			if err != nil {
				utils.ExitWithError(fmt.Errorf("could not read file %s: %w", inputFile, err))
			}

			err = json.Unmarshal(fileContent, &envData)
			if err != nil {
				utils.ExitWithError(fmt.Errorf("could not parse JSON from %s: %w", inputFile, err))
			}
		}

		var source string
		if sourceSupabase {
			source = fmt.Sprintf("Supabase (ID: %s)", supabaseID)
		} else {
			source = args[0]
		}
		fmt.Printf("--- Environment Summary from %s ---\n", source)
		fmt.Printf("Generated by StackMatch Version: %s\n", envData.StackmatchVersion)
		fmt.Printf("Scan Date: %s\n\n", envData.ScanDate.Format("2006-01-02 15:04:05 MST"))

		fmt.Println("System Information:")
		fmt.Printf("  OS: %s\n", envData.System.OS)
		fmt.Printf("  Architecture: %s\n", envData.System.Arch)
		fmt.Printf("  Shell: %s\n\n", envData.System.Shell)

		if len(envData.ConfiguredLanguages) > 0 {
			fmt.Println("Programming Languages:")
			for lang, version := range envData.ConfiguredLanguages {
				fmt.Printf("  - %s: %s\n", lang, version)
			}
			fmt.Println()
		}

		if len(envData.Tools) > 0 {
			fmt.Println("Development Tools:")
			for tool, version := range envData.Tools {
				fmt.Printf("  - %s: %s\n", tool, version)
			}
			fmt.Println()
		}

		if len(envData.PackageManagers) > 0 {
			fmt.Println("Package Managers:")
			for pm, version := range envData.PackageManagers {
				fmt.Printf("  - %s: %s\n", pm, version)
			}
			fmt.Println()
		}

		if len(envData.CodeEditors) > 0 {
			fmt.Println("Code Editors:")
			for editor, version := range envData.CodeEditors {
				fmt.Printf("  - %s: %s\n", editor, version)
			}
			fmt.Println()
		}

		if len(envData.ConfigFiles) > 0 {
			fmt.Println("Configuration Files:")
			for _, file := range envData.ConfigFiles {
				fmt.Printf("  - %s\n", file)
			}
			fmt.Println()
		}

		fmt.Println("--- End of Summary ---")

		if dryRun {
			fmt.Println("Note: This is a dry run. No changes have been made to your system.")
			return
		}

		// Start the installation process
		fmt.Println("\nStarting installation...")

		// Detect the best available package manager
		pm, err := installer.DetectPackageManager()
		if err != nil {
			utils.ExitWithError(fmt.Errorf("could not detect a supported package manager: %w", err))
		}

		fmt.Printf("Using package manager: %s\n", pm.Name())

		// Collect all packages to install
		var packagesToInstall []string

		// Add tools
		for tool := range envData.Tools {
			packagesToInstall = append(packagesToInstall, tool)
		}

		// Add package managers
		for pm := range envData.PackageManagers {
			packagesToInstall = append(packagesToInstall, pm)
		}

		// Add code editors
		for editor := range envData.CodeEditors {
			packagesToInstall = append(packagesToInstall, editor)
		}

		// Remove duplicates and sort
		packagesToInstall = uniqueStrings(packagesToInstall)

		// Install packages
		fmt.Printf("Installing %d packages...\n", len(packagesToInstall))
		startTime := time.Now()

		err = pm.InstallMultiple(cmd.Context(), packagesToInstall)
		if err != nil {
			utils.ExitWithError(fmt.Errorf("failed to install packages: %w", err))
		}

		elapsed := time.Since(startTime)
		fmt.Printf("\nInstallation completed in %s\n", elapsed.Round(time.Second))
	},
}

// uniqueStrings returns a new slice containing unique strings from the input slice
func uniqueStrings(input []string) []string {
	unique := make(map[string]bool)
	var result []string

	for _, item := range input {
		if !unique[item] {
			unique[item] = true
			result = append(result, item)
		}
	}

	return result
}

func init() {
	importCmd.Flags().BoolVar(&dryRun, "dry-run", true, "Show what would be installed without making changes")
	importCmd.Flags().BoolVar(&sourceSupabase, "from-supabase", false, "Import from Supabase instead of a local file")
	importCmd.Flags().StringVar(&supabaseID, "id", "", "Environment ID when importing from Supabase")
	rootCmd.AddCommand(importCmd)
}
