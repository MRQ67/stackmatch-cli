package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/MRQ67/stackmatch-cli/internal/utils"
	"github.com/MRQ67/stackmatch-cli/pkg/installer"
	"github.com/MRQ67/stackmatch-cli/pkg/types"
	"github.com/spf13/cobra"
)

var (
	dryRun bool
)

var importCmd = &cobra.Command{
	Use:   "import [filename]",
	Short: "Import a development environment from a StackMatch JSON file",
	Long: `Reads a StackMatch environment file and installs the tools and configurations.

By default, this command runs in dry-run mode, showing what would be installed
without making any changes. Use the --no-dry-run flag to perform the actual installation.`,
	Args: cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		inputFile := args[0]

		fileContent, err := os.ReadFile(inputFile)
		if err != nil {
			utils.ExitWithError(fmt.Errorf("could not read file %s: %w", inputFile, err))
		}

		var envData types.EnvironmentData
		err = json.Unmarshal(fileContent, &envData)
		if err != nil {
			utils.ExitWithError(fmt.Errorf("could not parse JSON from %s: %w", inputFile, err))
		}

		fmt.Printf("--- Environment Summary from %s ---\n", inputFile)
		fmt.Printf("Generated by StackMatch Version: %s\n", envData.StackmatchVersion)
		fmt.Printf("Scan Date: %s\n\n", envData.ScanDate.Format("2006-01-02 15:04:05 MST"))

		fmt.Println("System Information:")
		fmt.Printf("  OS: %s\n", envData.System.OS)
		fmt.Printf("  Architecture: %s\n", envData.System.Arch)
		fmt.Printf("  Shell: %s\n\n", envData.System.Shell)

		if len(envData.ConfiguredLanguages) > 0 {
			fmt.Println("Programming Languages:")
			for lang, version := range envData.ConfiguredLanguages {
				fmt.Printf("  - %s: %s\n", lang, version)
			}
			fmt.Println()
		}

		if len(envData.Tools) > 0 {
			fmt.Println("Development Tools:")
			for tool, version := range envData.Tools {
				fmt.Printf("  - %s: %s\n", tool, version)
			}
			fmt.Println()
		}

		if len(envData.PackageManagers) > 0 {
			fmt.Println("Package Managers:")
			for pm, version := range envData.PackageManagers {
				fmt.Printf("  - %s: %s\n", pm, version)
			}
			fmt.Println()
		}

		if len(envData.CodeEditors) > 0 {
			fmt.Println("Code Editors:")
			for editor, version := range envData.CodeEditors {
				fmt.Printf("  - %s: %s\n", editor, version)
			}
			fmt.Println()
		}

		if len(envData.ConfigFiles) > 0 {
			fmt.Println("Configuration Files:")
			for _, file := range envData.ConfigFiles {
				fmt.Printf("  - %s\n", file)
			}
			fmt.Println()
		}

		fmt.Println("--- End of Summary ---")

		if dryRun {
			fmt.Println("Note: This is a dry run. No changes have been made to your system.")
			return
		}

		// Start the installation process
		fmt.Println("\nStarting installation...")

		// Detect the best available package manager
		pm, err := installer.DetectPackageManager()
		if err != nil {
			utils.ExitWithError(fmt.Errorf("could not detect a supported package manager: %w", err))
		}

		fmt.Printf("Using package manager: %s\n", pm.Name())

		// Collect all packages to install
		var packagesToInstall []string

		// Add tools
		for tool := range envData.Tools {
			packagesToInstall = append(packagesToInstall, tool)
		}

		// Add package managers
		for pm := range envData.PackageManagers {
			packagesToInstall = append(packagesToInstall, pm)
		}

		// Add code editors
		for editor := range envData.CodeEditors {
			packagesToInstall = append(packagesToInstall, editor)
		}

		// Remove duplicates and sort
		packagesToInstall = uniqueStrings(packagesToInstall)

		// Install packages
		fmt.Printf("Installing %d packages...\n", len(packagesToInstall))
		startTime := time.Now()

		err = pm.InstallMultiple(cmd.Context(), packagesToInstall)
		if err != nil {
			utils.ExitWithError(fmt.Errorf("failed to install packages: %w", err))
		}

		elapsed := time.Since(startTime)
		fmt.Printf("\nInstallation completed in %s\n", elapsed.Round(time.Second))
	},
}

// uniqueStrings returns a new slice containing unique strings from the input slice
func uniqueStrings(input []string) []string {
	unique := make(map[string]bool)
	var result []string

	for _, item := range input {
		if !unique[item] {
			unique[item] = true
			result = append(result, item)
		}
	}

	return result
}

func init() {
	importCmd.Flags().BoolVar(&dryRun, "dry-run", true, "Show what would be installed without making changes")
	rootCmd.AddCommand(importCmd)
}
